#' Tidying methods for ordinal logistic regression models
#'
#' These methods tidy the coefficients of ordinal logistic regression
#' models generated by [ordinal::clm()] or [ordinal::clmm()]
#' of the `ordinal` package, [MASS::polr()] of the `MASS`
#' packge, or [survey::svyolr()] of the `survey` package.
#'
#' @param x a model of class `clm`, `clmm`, `polr` or `svyolr`
#' @template param_confint
#' @template param_exponentiate
#' @template param_quick
#' @template param_data
#' @template param_newdata
#' 
#' @param conf.type the type of confidence interval
#' (see [ordinal::confint.clm()])
#' 
#' @param type.predict type of prediction to compute for a CLM; passed on to
#' [ordinal::predict.clm()] or `predict.polr`
#' @param ... extra arguments
#' @name ordinal_tidiers
#'
#' @examples
#' library(ordinal)
#' clm_mod <- clm(rating ~ temp * contact, data = wine)
#' tidy(clm_mod)
#' tidy(clm_mod, conf.int = TRUE)
#' tidy(clm_mod, conf.int = TRUE, conf.type = "Wald", exponentiate = TRUE)
#' glance(clm_mod)
#' augment(clm_mod)
#' 
#' clm_mod2 <- clm(rating ~ temp, nominal = ~ contact, data = wine)
#' tidy(clm_mod2)
#' 
#' clmm_mod <- clmm(rating ~ temp + contact + (1 | judge), data = wine)
#' tidy(clmm_mod)
#' glance(clmm_mod)
#' 
#' library(MASS)
#' polr_mod <- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
#' tidy(polr_mod, exponentiate = TRUE, conf.int = TRUE)
#' glance(polr_mod)
#' augment(polr_mod, type.predict = "class")
NULL

#' @rdname ordinal_tidiers
#' @return
#' `tidy.clm`, `tidy.clmm`, `tidy.polr` and `tidy.svyolr`
#' return one row for each coefficient at each level of the response variable,
#' with six columns:
#'   \item{term}{term in the model}
#'   \item{estimate}{estimated coefficient}
#'   \item{std.error}{standard error}
#'   \item{statistic}{t-statistic}
#'   \item{p.value}{two-sided p-value}
#'   \item{coefficient_type}{type of coefficient, see [ordinal::clm()]}
#'
#' If `conf.int=TRUE`, it also includes columns for `conf.low` and
#'
#' @export
tidy.clm <- function(x, conf.int = FALSE, conf.level = .95,
                     exponentiate = FALSE, quick = FALSE,
                     conf.type = c("profile", "Wald"), ...) {
  if (quick) {
    co <- coef(x)
    ret <- data.frame(
      term = names(co), estimate = unname(co),
      stringsAsFactors = FALSE
    )
    return(process_clm(ret, x, conf.int = FALSE, exponentiate = exponentiate))
  }
  conf.type <- rlang::arg_match(conf.type)
  co <- coef(summary(x))
  nn <- c("estimate", "std.error", "statistic", "p.value")
  ret <- fix_data_frame(co, nn[seq_len(ncol(co))])
  process_clm(
    ret, x,
    conf.int = conf.int, conf.level = conf.level,
    exponentiate = exponentiate, conf.type = conf.type
  )
}


process_clm <- function(ret, x, conf.int = FALSE, conf.level = .95,
                        exponentiate = FALSE, conf.type = "profile") {
  if (exponentiate) {
    trans <- exp
  } else {
    trans <- identity
  }

  if (conf.int) {
    CI <- suppressMessages(
      trans(stats::confint(x, level = conf.level, type = conf.type))
    )
    colnames(CI) <- c("conf.low", "conf.high")
    CI <- as.data.frame(CI)
    CI$term <- rownames(CI)
    
    ret$orig_row_order <- seq_len(nrow(ret))
    ret <- merge(ret, unrowname(CI), by = "term", all.x = TRUE)
    ret <- ret[order(ret$orig_row_order),]
    ret$orig_row_order <- NULL
  }

  ret$estimate <- trans(ret$estimate)
  ## make sure original order hasn't changed
  if (!identical(ret$term,c(names(x$alpha),names(x$beta),names(x$zeta)))) {
      stop("row order changed; please contact maintainers")
  }
  ret$coefficient_type <- rep(c("alpha","beta","zeta"),
                              vapply(x[c("alpha","beta","zeta")],
                                     length, numeric(1)))
  as_tibble(ret)
}

#' @rdname ordinal_tidiers
#' @export
tidy.clmm <- function(x, conf.int = FALSE, conf.level = .95,
                      exponentiate = FALSE, quick = FALSE,
                      conf.type = c("profile", "Wald"), ...) {
  tidy.clm(x, conf.int, conf.level, exponentiate, quick, ...)
}

#' @rdname ordinal_tidiers
#' @evalRd return_glance(
#'   'edf',
#'   'logLik',
#'   'AIC',
#'   'BIC',
#'   'df.residual',
#'   'nobs'
#'   )
#' @export
glance.clm <- function(x, ...) {
  ret <- tibble(edf = x$edf)
  # survey-svyolr returns NULL AIC, BIC, logLik
  ret$AIC <- tryCatch(as.numeric(stats::AIC(x)), error = function(e) NULL)
  ret$BIC <- tryCatch(as.numeric(stats::BIC(x)), error = function(e) NULL)
  ret$logLik <- tryCatch(as.numeric(stats::logLik(x)), error = function(e) NULL)
  # clmm returns returns NULL df.residual
  ret$df.residual <- tryCatch(stats::df.residual(x), error = function(e) NULL)
  # nobs
  ret$nobs <- tryCatch(stats::nobs(x), error = function(e) NULL)
  ret
}

#' @rdname ordinal_tidiers
#' @evalRd return_glance(
#'   'edf',
#'   'logLik',
#'   'AIC',
#'   'BIC',
#'   'df.residual',
#'   'nobs'
#'   )
#' @export
glance.clmm <- glance.clm

#' @rdname ordinal_tidiers
#' @return
#' `augment.clm` and `augment.polr` returns
#' one row for each observation, with additional columns added to
#' the original data:
#'   \item{.fitted}{fitted values of model}
#'   \item{.se.fit}{standard errors of fitted values}
#'
#' `augment` is not supportted for [ordinal::clmm()]
#' and [survey::svyolr()] models.
#'
#' @export
augment.clm <- function(x, data = model.frame(x), newdata = NULL,
                        type.predict = c("prob", "class"), ...) {
  type.predict <- rlang::arg_match(type.predict)
  augment_columns(x, data, newdata, type = type.predict)
}
